---
- name: Gen_certs | create etcd cert dir
  file:
    path: "{{ etcd_cert_dir }}"
    group: "{{ etcd_cert_group }}"
    state: directory
    owner: "{{ etcd_owner }}"
    mode: "{{ etcd_cert_dir_mode }}"

- name: Create openssl.conf
  copy:
    src: openssl.conf
    dest: "{{ etcd_config_dir }}/openssl.conf"
    mode: "0644"
  register: openssl_conf

- name: Get or create etcd certificate authority
  run_once: true
  delegate_to: "{{ groups['etcd'][0] }}"
  block:
  - name: Get CA key
    stat:
      path: "{{ etcd_cert_dir }}/ca-key.pem"
      get_attributes: false
      get_checksum: false
      get_mime: false
    register: ca_key
  - name: Get CA cert
    slurp:
      src: "{{ etcd_cert_dir }}/ca.pem"
    changed_when: >
      etcd_ca_base64 is failed
      or ca_settings.public_key_type | lower != key_alg
    # TODO: more settings invalidate the CA
    vars:
      ca_settings: "{{ etcd_ca_base64.content | b64decode | community.crypto.x509_certificate_info }}"

    failed_when: false
    register: etcd_ca_base64
  - name: Generate CA
    when: not ca_key.stat.exists or etcd_ca_base64 is changed or openssl_conf is changed
    # TODO -> move to role defaults/
    vars:
      cert_role: ca
      step: ca
      subj:
        CN: etcd-ca
        # - cRLSign # we don't use this because the PKI is fully controlled by kubespray
        # revocation/invalidation happens by changing the root CA, not CRL
    command:
      argv: "{{ openssl_argv | flatten }}"
    register: etcd_ca

- name: Etcd PKI - clients
  vars:
    ca: "{{ (etcd_ca_base64.content | b64decode) if etcd_ca is skipped else etcd_ca.stdout }}"
  block:
  - name: Propagate etcd CA on etcd member and clients
    ansible.builtin.copy:
      content: "{{ ca }}"
      dest: "{{ etcd_cert_dir }}/ca.pem"
      mode: "0644"

  - name: Check etcd client certificate validity
    slurp:
      src: "{{ etcd_cert_dir }}/{{ item }}.pem"
    vars:
      cert_role_by_group:
        etcd: ['client', 'member']
        k8s_cluster: ['client']
      cert_info: "{{ etcd_client_certificate.content | b64decode | community.crypto.x509_certificate_info }}"
      ca_info: "{{ ca | community.crypto.x509_certificate_info }}"
      asn1_time_fmt: '%Y%m%d%H%M%S%z'
    loop: "{{ cert_role_by_group | dict2items | selectattr('key', 'in', group_names) | map(attribute='value') | flatten }}"
    register: etcd_client_certificate
    failed_when: false
    # TODO more customization of when a certificate should be regenerated
    #
    # Currently, handle:
    # - cert does not exist
    # - cert expired or near expiration
    # - certificate authority changed (using serial number)
    changed_when: >
      etcd_client_certificate is failed or
      (now().astimezone() - (cert_info.notAfter | ansible.builtin.to_datetime(asn1_time_fmt))) <
      (({'days': certificates_duration} | timedelta) / 5) or
      cert_info.authority_cert_serial_number != ca_info.serial_number

  - name: Etcd | Client certificates
    vars:
      subj:
        CN: "etcd-{{ cert_role }}"
    block:
    - name: Etcd | Generate certificate request
      vars:
        step: csr
      command:
        argv: "{{ openssl_argv | flatten }}"
      register: etcd_client_certificate_request
      loop: "{{ etcd_client_certificate.results | select('changed') | map(attribute='item') }}"
      loop_control:
        loop_var: cert_role

    - name: Etcd | Sign certificate request
      vars:
        cert_role: "{{ item.cert_role }}"
      delegate_to: "{{ groups['etcd'][0] }}"
      loop: "{{ etcd_client_certificate_request.results }}"
      register: etcd_client_certificate
      command:
        argv: "{{ openssl_argv_ca | flatten }}"
        stdin: "{{ item.stdout }}"
      loop_control:
        label: "{{ item.cert_role }}"

  - name: Etcd client | Copy certificate
    loop: "{{ etcd_client_certificate.results | map(attribute='item') }}"
    ansible.builtin.copy:
      content: "{{ item.stdout }}"
      dest: "{{ etcd_cert_dir }}/{{ item.cert_role }}.pem"
      mode: "0644"
